# День 2: CDR хранилище (LSM Tree)

Сегодня мы будем строить хранилище для **CDR (Call Detail Records)** — записей о звонках и сессиях.
Специфика: 
1. Данные льются огромным потоком (тысячи записей в секунду).
2. Мы не можем терять данные (нужен WAL - write ahead log).
3. Читаем мы их редко (только для биллинга или аналитики), но диапазонами (Scan за период).

Обычная запись в файл (B-Tree) убьет диск случайными seek-ами. Мы используем **LSM (Log-Structured Merge Tree)**, чтобы писать всегда последовательно (Sequential Write).

## Поток данных (LSM Pipeline)

```mermaid
flowchart TD
    Client[CDR Source] -->|Put| WAL[WAL (Disk)]
    Client -->|Put| Mem[Memtable (RAM)]
    
    subgraph Memory
        Mem
    end
    
    subgraph Disk
        WAL
        SST1[SSTable 1]
        SST2[SSTable 2]
        SST3[SSTable 3]
    end

    Mem -->|Full? Flush| SST1
    SST1 -->|Compaction| SST2
    SST2 -->|Compaction| SST3
    
    style WAL fill:#f96,stroke:#333
    style Mem fill:#6f9,stroke:#333
```

## Какие навыки мы будем развивать
- **Работа с диском**: бинарные форматы файлов, буферизация, fsync.
- **Отказоустойчивость**: восстановление состояния после `kill -9`.
- **Архитектура Storage Engine**: понимание жизненного цикла данных (Hot -> Warm -> Cold).

## Задание

### 1) SSTable (Неизменяемые файлы)
Реализуйте `internal/sstable`.
CDR хранятся в файлах, отсортированных по времени (ключу).
- **Writer**: пишет пары последовательно, создает индекс (Sparse Index) в конце файла.
- **Reader**: использует индекс, чтобы не читать весь файл ради одной записи.

### 2) WAL (Write Ahead Log)
Реализуйте `internal/wal`.
Прежде чем положить данные в память (Memtable), мы пишем их в `append-only` лог.
**Условие**: Если программа упала, при рестарте мы читаем WAL и восстанавливаем Memtable.

### 3) LSM Engine & Compaction
Реализуйте `internal/lsm`.
- Когда Memtable переполняется (например, > 1MB) -> сбрасываем её в новый SSTable файл.
- **Compaction (Сборка мусора)**: Файлов становится слишком много. Фоновый процесс должен брать 2-3 маленьких SSTable и сливать их в один большой, выбрасывая дубликаты и удаленные записи.

### 4) Дополнительно
У вас есть выбор стратегии Compaction.
1. Запишите 100 МБ данных маленькими кусками.
2. Посмотрите, сколько *реально* байт записалось на диск (с учетом WAL, Flush, и Compaction).
3. В **заметке** ответьте: 
   - Если мы делаем Compaction очень часто, что страдает: CPU, Диск (запись) или Диск (чтение)?
   - Почему для CDR данных (пишем много, читаем редко) выгодно откладывать Compaction?

## Контрольные точки
- **Crash Test**: Запустите `kvtool load`, убейте процесс (`CTRL+C`), запустите снова. Данные должны быть на месте (из WAL).
- **Compaction Test**: Запишите один и тот же ключ 10 раз с разными значениями. После Compaction на диске должна остаться только 1 запись.

## Проверка
```bash
make test-day2
```

## Критерии приёмки
- Тесты проходят.
- Вы понимаете разницу между Random Write (плохо) и Sequential Write (хорошо).
- WAL гарантирует устойчивость к потерям данных.

## Уровни выполнения
### Уровень A — минимум
Вам нужно:
- реализовать обязательный функционал дня так, чтобы проходили тесты `make test-day2`;
- кратко описать принятые решения в заметке (шаблон: `docs/note_template.md`).

### Уровень B — стандарт (хорошо)
Дополнительно нужно:
- добавить 1–2 бенчмарка на критичные операции дня и зафиксировать тренд при росте N;
- добавить тесты на крайние случаи (пустые ключи/значения, диапазоны, повторы ключей, удаления).

### Уровень C — продвинутый (отлично)
Дополнительно нужно:
- найти и объяснить одно узкое место (память/аллокации/лишний I/O) и показать улучшение измерением;

## Антипаттерны (снижают оценку)
- Скрытое глобальное состояние, влияющее на тесты.
- Паники в библиотечном коде вместо ошибок.
- “Магия” без объяснения: использование констант или алгоритмов без понимания, почему они такие.
- Непредсказуемый порядок выдачи результатов там, где требуется упорядоченность.

# Точки самостоятельного выбора (допустимые варианты решений)

Здесь перечислены места, где вы можете выбрать свой вариант реализации.
Условие одно: внешние ко и инварианты должны сохраняться, а эффект должен быть проверяемым (тестами или бенчмарками).

## День 2: SSTable / WAL / LSM
- формат SSTable:
  - простой (все записи подряд + footer);
  - блоки данных + индекс блоков;
  - минимальный sparse-index по ключам.
- итератор чтения:
  - линейное чтение блока;
  - поиск по sparse-index и чтение только нужных блоков.
- WAL:
  - length-prefixed записи;
  - crc/контроль целостности (опционально).
- удаление:
  - tombstone (обязательный для LSM);
  - физическое удаление только на compaction.
- compaction:
  - “слить всё L0” по достижении порога;
  - L0→L1 с ограничением числа файлов.