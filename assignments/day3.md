# День 3: Anti-Fraud & Analytics

Поздравляем, вы почти на финишной прямой! Сегодня задание следующее: есть база "подозрительных" IMSI (Fraud Database), хранящаяся в LSM.
Каждый звонок в сети мы проверяем по этой базе.
Проблема: 99.9% абонентов — честные. Если на каждый звонок лезть в диск (искать в SSTable), мы положим подсистему ввода/вывода.
Решение: использовать **Bloom Filter** при проверке.

Также нам нужно в реальном времени видеть "Top Talkers" (кто генерирует аномальный трафик), не сохраняя терабайты логов.
Решение: **Потоковые алгоритмы (Count-Min Sketch)**.

## Bloom Filter Flow

```mermaid
flowchart TD
    Req[Get(Key)] --> Bloom{Bloom Filter?}
    Bloom -- "No (definitely)" --> Ret404[Return Not Found]
    Bloom -- "Maybe (prob 99%)" --> Disk[Read SSTable from Disk]
    Disk -- "Found" --> RetVal[Return Value]
    Disk -- "Not Found (False Positive)" --> Ret404
    
    style Bloom fill:#f9f,stroke:#333
    style Disk fill:#f96,stroke:#333
    style Ret404 fill:#9f9,stroke:#333
```

## Какие навыки мы будем развивать
- **Вероятностные структуры**: понимание цены "ошибки" (False Positive) и выигрыша в скорости.
- **Приближенные вычисления**: как посчитать топ-10 элементов в потоке из миллиарда, используя 1 КБ памяти.
- **Профилирование**: доказательство, что оптимизация действительно работает.

## Задание

### 1) Bloom Filter ("Охранник диска")
Реализуйте `internal/bloom`.
- Фильтр создается для каждого SSTable при его записи.
- При чтении: сначала спроси фильтр. Если он сказал "нет" — не открывай файл.

**Исследовательская задача:**
Создайте синтетический тест (DDoS атаку): 10 000 запросов несуществующих ключей.
Сравните количество обращений к "диску" (мокам SSTable) с фильтром и без.
Результат должен быть виден в бенчмарке.

### 2) Streaming Analytics (Count-Min Sketch)
Реализуйте `internal/stream`.
Мы хотим знать IMSI, которые совершают больше всего звонков.
Реализуйте **Count-Min Sketch**, который потребляет фиксированную память (например, 10 КБ) и выдает приближенную частоту появления ключа.

Интегрируйте это в `kvtool`:
```bash
go run ./cmd/kvtool load -count 100000 -zipf 1.1 -report
```
(флаг `-zipf` генерирует неравномерное распределение, чтобы были "горячие" ключи).

## Выбор параметров
Вы должны выбрать размеры структур (m, k для Bloom; w, d для Sketch) в зависимости от требований.
В **заметке** обоснуйте: "Я выбрал 10 бит на элемент в Bloom, чтобы получить False Positive rate ~1%".

## Проверка
```bash
make test-day3
```

## Критерии приёмки
- Bloom Filter действительно отсекает 90%+ ненужных чтений в тесте.
- Count-Min Sketch находит "топ-элементы" с приемлемой погрешностью.

## Уровни выполнения
### Уровень A — минимум
Вам нужно:
- реализовать обязательный функционал дня так, чтобы проходили тесты `make test-day3`;
- кратко описать принятые решения в дизайн-заметке (шаблон: `docs/note_template.md`).

### Уровень B — стандарт (хорошо)
Дополнительно нужно:
- добавить 1–2 бенчмарка на критичные операции дня и зафиксировать тренд при росте N;
- добавить тесты на крайние случаи (пустые ключи/значения, диапазоны, повторы ключей, удаления).

### Уровень C — продвинутый (отлично)
Дополнительно нужно:
- найти и объяснить одно узкое место (память/аллокации/лишний I/O) и показать улучшение измерением;

## Антипаттерны (снижают оценку)
- Скрытое глобальное состояние, влияющее на тесты.
- Паники в библиотечном коде вместо ошибок.
- “Магия” без объяснения: использование констант или алгоритмов без понимания, почему они такие.
- Непредсказуемый порядок выдачи результатов там, где требуется упорядоченность.

# Точки самостоятельного выбора (допустимые варианты решений)

Здесь перечислены места, где вы можете выбрать свой вариант реализации.
Условие одно: внешние ко и инварианты должны сохраняться, а эффект должен быть проверяемым (тестами или бенчмарками).

## День 3: Bloom / streaming
- Bloom:
  - double hashing (2 хеша → k);
  - отдельные k независимых хешей (обычно дороже).
- параметры Bloom:
  - фиксированные (для простоты);
  - вычисление m/k по целевому false positive.
- streaming:
  - Count-Min Sketch (частоты);
  - reservoir sampling (выборка).