# День 1: HLR, High-Load и SkipList

## Home Location Register (HLR)
В мобильных сетях HLR — это очень важная база данных, которая хранит профиль абонента и его текущее местоположение (VLR адрес). 
Нагрузка на HLR нестандартная:
- **Высокая интенсивность чтения**: каждый входящий звонок/смс требует поиска абонента.
- **Постоянные обновления**: абоненты перемещаются, меняют статусы.
- **Поиск по расстоянию**: иногда нужно выгрузить всех абонентов определенного региона (префикс IMSI) для аналитики или миграции.

Классические Hash Map не подходят из-за отсутствия range-запросов. 
Сбалансированные деревья (КЧ деревья, АВЛ) сложны в реализации (особенно конкурентные версии).
Поэтому часто в подобных задачах прибегают к использованию **SkipList**.

## SkipList: Вероятностная структура
SkipList заменяет сложную детерминированную балансировку дерева на простую вероятностную модель ("подбрасывание монетки").

### Интуиция
Представьте, что вы едете на экспрессе:
- Уровень 0: остановки у каждого столба (связный список всех элементов).
- Уровень 1: остановки только на крупных станциях.
- Уровень 2: остановки только в столицах регионов.

Чтобы найти элемент, мы начинаем с верхнего уровня ("экспресса"), доезжаем максимально близко, спускаемся ниже и уточняем.

### Почему это работает в высоконагруженных системах?
1. **Простота**: код в 3 раза короче, чем у КЧ деревьях. Меньше багов.
2. **Локальность**: при сканировании (выполнении Scan) мы просто бежим по нижнему уровню (последовательный доступ к памяти), что процессору "нравится" больше, чем прыжки по дереву.
3. **Конкурентность**: в SkipList локальные обновления (Insert/Delete) затрагивают только "соседей", тогда как балансировка дерева может заблокировать большую ветку.

## MapReduce и упорядоченность
MapReduce — это не только про Hadoop. Это паттерн "Разделяй и Властвуй".
- **Map**: превращаем сырые данные (логи, тексты) в пары `(Key, Value)`.
- **Shuffle/Sort**: группируем данные по ключу. Вот тут важен **упорядоченный итератор** нашего KV-хранилища.
- **Reduce**: сворачиваем данные по каждому ключу.

В задании мы используем SkipList как "движок сортировки" для in-memory MapReduce. Данные загружаются в SkipList, а затем `Scan` отдает их уже отсортированными для Reduce-фазы.

## Где смотреть в коде
- Контракт KV: `internal/kv/kv.go`
- Логика MapReduce: `internal/mapreduce/mapreduce.go`
- Задание: `assignments/day1.md`
