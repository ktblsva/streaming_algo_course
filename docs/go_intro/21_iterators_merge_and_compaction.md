## Итераторы, merge и compaction (LSM-мышление в некотором минимальном виде)

В первый день вы делаете упорядоченный `Scan` по in-memory структуре. Во второй день это превращается в “склейку” нескольких упорядоченных источников:
- Memtable (самая свежая)
- несколько SSTable (L0/L1/…)

### 1) Базовая задача здесь: merge двух отсортированных потоков
Если есть два источника (итератора) ключей по возрастанию, то “слияние” делается как в merge sort:
- держим “текущий” элемент каждого;
- возвращаем меньший ключ;
- продвигаем только тот итератор, из которого взяли элемент.

### 2) Когда ключи совпали (дубликаты)
В LSM дубликаты неизбежны: один и тот же ключ может лежать в Memtable и в нескольких SSTable.

Правило “победителя” обычно такое:
- **самая новая запись побеждает**.

Практически это означает:
- если вы мержите источники “от свежих к старым”, то при равных ключах берите из более свежего, а старый пропускайте.

### 3) Удаления: tombstone
В LSM удаление почти всегда реализуется как запись “маркера удаления” (tombstone).
Почему так:
- SSTable неизменяемая; физически удалить ключ “в середине” нельзя;
- маркер удаляет логически, а физическое удаление происходит на compaction.

Следствие для итератора:
- если самая свежая запись для ключа — tombstone, то ключ **не должен** возвращаться наружу.

### 4) Range scan в LSM
`Scan(start,end)` для LSM — это “итератор поверх мержа”:
- каждый источник отдаёт диапазон **[start,end)**;
- общий merge-итератор выдаёт уникальные ключи в порядке;
- применяет правила “новизна побеждает” и “tombstone скрывает”.

### 5) Compaction как merge “на диск”
Compaction — это тот же merge, только вместо “выдачи наружу” вы:
- читаете несколько SSTable (старые уровни);
- пишете один новый SSTable;
- выкидываете:
  - дубликаты (оставляя самый новый);
  - ключи, которые удалены tombstone’ом (если можно гарантировать, что ниже нет “живых” версий).

### 6) Мини-упражнение (если хотите испытать свои силы и понимание)
Сделайте merge двух отсортированных слайсов `[]kv.Pair`:
- вход: `[(a,1),(c,3)]` и `[(b,2),(c,30),(d,4)]`
- выход (по правилу “правая новее”): `a=1,b=2,c=30,d=4`

Потом ментально замените слайсы на итераторы — логика та же.

### 7) На чем чаще всего ломаются (и скорей всего у вас будет так же) тесты
- неправильная включительность `end` (должно быть **[start,end)**);
- “победитель” по дубликатам выбран неверно (старое перетирает новое);
- tombstone не скрывает ключ;
- итератор выдаёт ключи не по возрастанию.
