## Слайсы, строки, байты: чтобы не стрелять себе в ногу и не тратить время на изучение всего что есть в языке Go

В заданиях ключи/значения — `[]byte`. Ошибки обычно происходят из-за алиасинга слайсов, лишних аллокаций, неочевидных конвертаций.

### 1) Слайс — это “окно” в массив
`[]byte` содержит указатель на массив + `len` + `cap`. Если вы сохраняете `[]byte` “как есть”, а потом кто-то меняет исходный буфер — вы получите неожиданные баги, на которые потребуется не мало времения для поиска и исправления.

Практическое правило для разрабатываемого хранилища:
- **на `Put` копируйте** `key` и `value` в собственную память (безопаснее и проще);
- отдавая `Get`, можно возвращать копию (безопаснее) или ссылку (быстрее, но требует дисциплины).

Мини-шаблон копирования:

```go
func clone(b []byte) []byte {
  if b == nil { return nil }
  out := make([]byte, len(b))
  copy(out, b)
  return out
}
```

### 2) `string(b)` — это копия
Конвертация `[]byte -> string` создаёт новую строку (копирует данные). В горячих (часто вызываемых) местах (итерация, merge) избегайте таких конвертаций.

Разрешено:
- печать/логирование;
- тестовые ассерты.

### 3) `append` и capacity
`append` может выделить новый массив и скопировать данные.
Если вы знаете размер заранее — предвыделяйте:

```go
keys := make([][]byte, 0, 1024)
```

### 4) `map` и порядок
`map` не гарантирует порядок обхода. Поэтому `map` не может заменить `Scan`.
Если вам нужен порядок — нужен упорядоченный индекс (SkipList/SSTable/merge итераторов).

### 5) Сравнение ключей
Для `[]byte` используйте:
- `bytes.Compare(a, b)` для порядка;
- `bytes.Equal(a, b)` для равенства.

Для первого дня это критично: в `internal/skiplist/skiplist.go` прямо заложено использование `bytes.Compare`.

### 6) Упражнения (на 10–15 минут) для закрепления понимания
1) Напишите `clone` (выше) и убедитесь тестом, что изменение исходного слайса не меняет сохранённый.
2) Напишите `cmp(a,b []byte) int` как обёртку над `bytes.Compare` и используйте её в нескольких местах (не копируя код сравнения).
3) Посмотрите на вывод `go test -run TestName -count=1` и убедитесь, что тесты не зависят от порядка `map` (если вы её используете где-то в промежуточных шагах).
