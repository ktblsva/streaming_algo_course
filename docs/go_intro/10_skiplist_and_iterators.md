## Трек первого дня: SkipList + `Scan` + итераторы (под `make test-day1`)

Связанные материалы:
- Задание: `assignments/day1.md`
- Теория: `docs/day1_hls_map_reduce_skiplist.md`
- Контракт KV (семантика Scan): `internal/kv/kv.go`
- Чеклист: `docs/review_checklist.md`

### 0) Что от вас будем ждать
В `internal/skiplist` нужно реализовать упорядоченное in-memory хранилище с операциями:
- `Put(key,value)` — вставка/обновление;
- `Get(key)` — поиск;
- `Delete(key)` — удаление;
- `Scan(start,end)` — **ленивый** итератор по диапазону **[start, end)**.

Ключи/значения — `[]byte`, сравнение — лексикографическое (`bytes.Compare`).

### 1) Семантика `Scan([start,end))` (самая частая причина падений)
Требования из контракта:
- диапазон **включает** `start`;
- диапазон **не включает** `end`;
- `start == nil` означает \(-∞\) (начало списка);
- `end == nil` означает \(+∞\) (конец списка).

Примеры (для интуиции):
- `Scan(nil,nil)` → все ключи по возрастанию.
- `Scan([]byte("b"), []byte("d"))` по ключам `a,b,c,d,e` → вернёт `b,c`.

### 2) Минимальный план реализации SkipList
Не привязываясь к конкретным полям, архитектура обычно такая:
- `node`: `key []byte`, `value []byte`, `next []*node` (forward pointers по уровням)
- `head` (сентинел) с `next` длины `maxLevel`
- RNG с `seed` из `New(seed)`
- `randomLevel()` (монетка) для высоты башни

Ключевой хелпер: найти “предшественников” на каждом уровне.

Идея, упрощенно, следующая:
- поиск идёт сверху вниз;
- на каждом уровне двигаемся вправо пока `next.key < key`;
- запоминаем “последний узел перед позицией” в массив `update[level]`.

### 3) `Put`: вставка или обновление
Алгоритм:
- найти `update[]` и кандидата на уровне 0;
- если ключ совпал — **обновить value** (и вернуть `nil`);
- иначе создать новый узел с высотой `lvl` и “вшить” его, поправив `next` указатели на уровнях `0..lvl-1`.

Практический совет (про байты):
- безопаснее копировать `key`/`value` на `Put` (см. `03_slices_maps_strings_bytes.md`), иначе легко получить алиасинг.

### 4) `Get`: поиск
Стандартный поиск сверху вниз:
- идти вправо пока `next.key < key`;
- спускаться на уровень ниже;
- на уровне 0 проверить равенство ключа.

Если не найдено — вернуть `skiplist.ErrNotFound` (именно эту ошибку тесты ожидают для `internal/skiplist`).

### 5) `Delete`: удаление
Похоже на `Put`, но:
- находите `update[]`;
- если кандидат равен ключу — для каждого уровня, где он встречается, перелинкуйте `update[level].next[level]`.
- если ключа нет — вернуть `skiplist.ErrNotFound` (внутренний адаптер к `kv.Store` может трактовать иначе).

### 6) Итератор: ленивость и порядок
`Scan` должен вернуть итератор, который:
- стартует с первого элемента \(\ge start\) (или с начала при `start=nil`);
- на `Next()` возвращает текущую пару и двигается по уровню 0;
- останавливается, когда `end != nil` и `key >= end`.

Важно:
- итератор **не должен** сначала собирать все результаты в `[]Pair` (это ломает смысл Range Scan и память).

### 7) Как связать с `kvtool`
В `cmd/kvtool` для `-store skiplist` используется адаптер `internal/kv/memskiplist`, который оборачивает `internal/skiplist` в `kv.Store`.
Поэтому после реализации `internal/skiplist` должно заработать:

```bash
go run ./cmd/kvtool wordcount -in ./testdata/text_small.txt -store skiplist
```

### 8) Выходные критерии первого дня, должны быть следующими
- `make test-day1` зелёный.
- Вы можете объяснить в 2–3 предложениях, зачем `seed` в `New(seed)` (воспроизводимость).
- Есть короткая заметка по шаблону `docs/note_template.md` (минимум: какие решения приняли и как проверяли).
