## База Go, которая точно понадобится

Для выполнения заданий школы вам не нужен “весь Go”, но нужны 6 вещей: **типы и методы**, **интерфейсы**, **ошибки**, **байты/строки**, **контекст выполнения**, **структура пакетов**.

### 1) Пакеты и структура проекта
- `internal/kv/kv.go` — контракт KV хранилища (`kv.Store`, `kv.Iterator`, `ErrNotFound`).
- `internal/skiplist` — задание первого дня (in-memory, `Scan` и итератор).
- `internal/wal`, `internal/sstable`, `internal/lsm` — задание второго дня (диск и LSM).
- `cmd/kvtool` — CLI для запуска демо/нагрузки.

Правило: **публичное** (методы, переменные, все что используется в нескольких исходных файлах) в Go начинается с заглавной буквы (`Store`, `Put`), **непубличное** — со строчной (`iter`, `findPredecessors`).

### 2) `struct` и методы: указатель или значение
Обычно хранилища — это структуры с внутренним состоянием, поэтому методы — на указателе:

```go
type Store struct {
  // поля состояния
}

func (s *Store) Put(key, value []byte) error { /* ... */ return nil }
```

Зачем `*Store`:
- в структуре метод меняет состояние (вставка/удаление);
- копирование структуры может быть дорогим/некорректным.

### 3) Интерфейсы: контракт важнее реализации
В `internal/kv/kv.go` ключевой контракт:
- `Put/Get/Delete`
- `Scan(ctx, start, end)` возвращает итератор по диапазону **[start, end)**, где `nil` — это \(-∞\) / \(+∞\).

Идея тут простая: утилита (`kvtool`) и MapReduce работают **через интерфейс**, а вы подсовываете реализацию (memmap/skiplist/lsm).

### 4) Ошибки: без паник (все panic ошибки при возникновении должны быть устранены), с контекстом
В библиотечном коде (внутренние пакеты) избегайте `panic`. Вместо этого:
- возвращайте `error`;
- при прокидывании добавляйте контекст через `%w`.

```go
if err != nil {
  return fmt.Errorf("read wal: %w", err)
}
```

Для “ключ не найден” в верхнем уровне кода используется `kv.ErrNotFound`. Конкретная реализация может иметь свою ошибку (например `skiplist.ErrNotFound`), а адаптер отображает её в `kv.ErrNotFound` (смотрите код в `internal/kv/memskiplist`).

### 5) `[]byte` vs `string`
Ключи и значения в коде — `[]byte`.
- сравнение ключей: используйте `bytes.Compare(a, b)` (в `internal/skiplist/skiplist.go` это прямо подсказано).
- конвертировать в `string` стоит только для логов/печати, не в часто вызываемых местах.

### 6) `context.Context`
Интерфейс `kv.Store` принимает `ctx context.Context` даже в однопоточном варианте.
Смысл: внешний код (CLI/тесты) может захотеть отменить долгий `Scan`/`Compaction` и т.п.
На практике для первого дня можно игнорировать `ctx`, но **не хранить его глобально**.

### 7) Мини-упражнение: “болванка” KV на map
Это не решение задания (там нужен порядок и `Scan`), а только чтобы вникнуть в API.

```go
type MapStore struct{ m map[string][]byte }

func NewMapStore() *MapStore { return &MapStore{m: map[string][]byte{}} }
```

Сделайте `Put/Get/Delete`, а на `Scan` честно верните ошибку “не поддерживается” — чтобы понять, почему в заданиях первого дня нужно упорядоченное управление.

### Ссылки на материалы проекта
- Теория первого дня (зачем `Scan` и сортировка): `docs/day1_hls_map_reduce_skiplist.md`
- Контракт KV: `internal/kv/kv.go`
